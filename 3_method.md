# 3章 火曜日：メソッド
コードにあるオブジェクトは互いに常にやり取りをしている。JavaやC langではコンパイラがこのやり取りを統括している。
すべてのメソッド呼び出しに対して、合致するメソッドをオブジェクトが持っているかどうかをコンパイラがチェックする。これは静的型チェックと呼ばれ、この仕組みを使う言語は静的言語と呼ばれる。存在しないメソッドを呼び出すとコンパイラは怒るのだ。

rubyやpythonなどの動的言語にはコンパイラはないので存在しないメソッドを呼び出すコードがあっても、その呼出部分が実行されない限りは問題は起きない。

コンパイラによる静的チェックをしてもらうにはコストがかかる。静的言語では退屈なメソッドを繰り返し書かないといけない。これをボイラープレートメソッドと呼ぶ。(ボイラープレートメソッドはコンパイラを喜ばせるためにあるらしい)

重複するコードを排除するには2つの方法が考えられる。
1. 動的メソッド
2. method_missing

## 3.2 動的メソッド
重複するコードを排除する

## 3.2.1 メソッドを動的に呼び出す
通常、メソッドを呼び出すにはドット記法を用いる(例、obj.hoge)が、 `Object#send` を使って呼び出すこともできる。
sendの第一引数は、オブジェクトに送信するメッセージ、つまりメソッド名になる。(文字列かシンボルで指定する)それ以外の引数(とブロック引数)は、そのままメソッドに渡される。

```
class MyClass
  def my_method(my_arg)
    my_arg * 2
  end
end

obj = MyClass.new

# ドット記法
obj.my_method(3) # => 6

# sendを使う
obj.send(:my_method, 3) # => 6
```

sendを使えば呼び出したいメソッド名が引数になるので、コードの実行時に呼び出すメソッドを動的に決定することが可能になる。

### メソッド名とシンボル
文字列の代わりにシンボルを使うのは慣習らしい。
シンボル「何かの名前」に使われることが多い。特にメソッド名などのメタプログラミングに関係する名前
シンボルが名前に適しているのは**文字列と違いイミュータブル**であるからだ。

## 3.2.3 メソッドを動的に定義する
`Module#define_method` を使うと `def` を使わなくてもメソッドを定義できる。
define_methodで定義するメソッドは呼びだされた時にメソッドが定義される。この手法を動的メソッド定義とよぶ。
def ではなく、 define_method を使うのは実行時にメソッド名を定義できるから。

```
class MyClass
  define_method :my_method do |my_arg|
    my_arg * 3
  end
end

obj = MyClass.new
obj.my_method(2) # => 6

m = MyClass.new
m.methods(false) # => [] my_methodは定義されていない
```

## 3.3 method_missing
rubyにはメソッド呼び出しを制限する静的チェックは存在しないので、存在しないメソッドを呼ぶことが可能。
実際に存在しないメソッドが呼ばれるとBasicObjectのプライベートメソッドの `method_missing` が呼ばれる
method_missingは呼ばれると下記のようになる

```
Class.new.send(:method_missing, :hoge)
# NoMethodError: undefined method `hoge' for #<Class:0x00007f90c4cafc18>
```

## 3.3.1 method_missingのオーバーライド
method_missingをオーバーライドすると不明なメッセージを途中で捕まえることができる。
method_missingまでたどりついたメッセージは、呼び出そうとしたメソッド名(と引数とブロックを持っている)

```
MyClassへのメソッド呼び出しで存在しないものだったら、かきのオーバーライドされたmethod_missingが呼ばれる

class MyClass
  def method_missing(method_name, *args, &blk)
    puts '呼び出した:#{method_name}'
  end
end
```

## 3.3.2 ゴーストメソッド
method_missingをオーバライドして、呼び出されたメソッドが存在しなくてもなんらかの処理を行い、呼び出し側から見ると通常の処理のように振る舞いが起きることをゴーストメソッドと呼ぶ。 

## 3.3.3 動的プロキシ
ゴーストメソッドを補足して、他のオブジェクトに転送するプロキシオブジェクトなどは動的プロキシと呼ばれる

### プロキシオブジェクト
プロキシ(Proxy)とは代理などの意味を持ち、対象のクラスの前に１つクラスを挟んで、番人(や代理人)のような役割をもたせること。
本物のクラスに対して、特定の関心事を担当し、それ以外を対象サブジェクトにわたすのが役割

プロキシに3つの種類がある
1. 防御
2. 仮想
3. リモート

### 防御プロキシ
本物のクラスと同じインターフェース(メソッド)を持つ。本物のクラスやそのオブジェクトに対してメッセージを送る前に認証を行うなどをすることで本物のクラスから「認証」という責務を分離している。
利用者はこの防御プロキシを通して本物のクラスにアクセスすることになる。
### 仮想プロキシ
仮想プロキシでは、負荷のかかるオブジェクト生成のタイミングを遅くしてアプリケーションのパフォーマンスをあげるために持ちられる
### リモートプロキシ


参考：[プロキシ(Proxy) \| Ruby デザインパターン | 酒と涙とRubyとRailsと](https://morizyun.github.io/ruby/design-pattern-proxy.html)

## 3.5 ブランクスレート
method_missingで捕まえることを想定したコードを書いていると、継承しているクラスのメソッドや定数が呼び出されてしまい、意図した動作にならないことがある。それをさけるためにブランクスレートという手法が用いられる。(Objectクラスや、Kernelは多くのメソッドを定義しているためこういうことが起こる)
これを避けるためには、継承するメソッドをへらす方法と継承しているクラスにある必要ないメソッドや定数を削除する方法がある。
メソッドを減らす方法としては `BasicObject` クラスを継承することが挙げられる。 `BasicObject` クラスは `Object` クラスと違い、必要最低限のメソッドしか継承していないため、新しいクラスを作成する時に明示的にスーパークラスを `Object` から `BasicObject` クラス に変更すればいい。

またメソッドを削除するには、継承ツリーの Objectの下に新たなクラスをインクルードし、そのクラスの中で、必要ないメソッドに対して `undef_method` を使用すればいい。
この新しいクラスはブランクスレートと呼ばれる。
`undef_method` の使い方はこちらを参照 [undef_method (Module) - Rubyリファレンス](https://ref.xaio.jp/ruby/classes/module/undef_method)

## 3.6.1 動的メソッド 対 ゴーストメソッド
結論としては、可能であれば動的メソッドを使い、仕方なければゴーストメソッドを使う だ。
ゴーストメソッドしか使えない場面としては、メソッド呼び出しが大量にある・呼び出すメソッドが実行時にわからないなどが挙げられる(gemなど他の開発者が使うインターフェースで、様々な使われ方が想定されるなど)
